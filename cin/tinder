#!/usr/bin/env python3
# This file is placed in the Public Domain.
# pylint: disable=W0611


import os
import shutil
import sys
import termios
import time
import traceback
import _thread


sys.path.insert(0, os.getcwd())


from opv.handler import Event, Handler, launch, scan
from opv.objects import Default, Object, update
from opv.storage import Storage
from opv.utility import elapsed, locked
from opv.modules import cmd, fnd, irc, rss


paylock = _thread.allocate_lock()


Cfg = Default()
Cfg.debug = True
Cfg.name = "tinder"


Storage.workdir = ".test"


scan(cmd)
scan(fnd)
scan(irc)
scan(rss)


errors = []
events = []
results = []


SKIP = ["debug",]


param = Object()
param.add = ["test@shell", "bart", ""]
param.cfg = ["server=localhost", ""]
param.rem = ["reddit", ""]
param.dpl = ["reddit title,summary,link", ""]
param.flt = ["0", ""]
param.fnd = [
             "config",
             "rss",
             "config server==localhost",
             "rss rss==reddit"
            ]
param.nme = ["reddit reddit"]
param.dpl = ["reddit title,link"]
param.rem = ["reddit"]
param.rss = ["https://www.reddit.com/r/python/.rss"]
param.thr = [""]


class CLI(Handler):

    @staticmethod
    def announce(txt):
        CLI.raw(txt)

    @staticmethod
    def raw(txt):
        if txt and "v" in Cfg.opts:
            cprint(txt)


def consume(evts):
    fixed = []
    res = []
    for evt in evts:
        evt.wait()
        fixed.append(evt)
    for fff in fixed:
        try:
            evts.remove(fff)
        except ValueError:
            continue
    return res


def cprint(txt):
    print(txt)
    sys.stdout.flush()


def doskip(txt):
    for skp in SKIP:
        if skp in txt:
            return True
    return False


#@locked(paylock)
def payload(clt):
    cmds = sorted(Handler.cmds)[::1]
    nmr = 0
    for cmnd in cmds:
        for ex in getattr(param, cmnd, [""]):
            evt = Event()
            evt.txt = cmnd + " " + ex
            evt.orig = repr(clt)
            evt.parse(evt.txt)
            clt.put(evt)
            events.append(evt)
            nmr += 1
    return nmr


def listmod(path):
    res = []
    if not os.path.exists(path):
        return res
    for fnm in os.listdir(path):
        if fnm.endswith("~") or fnm.startswith("__"):
            continue
        res.append(fnm.split(os.sep)[-1][:-3])
    return res


def scandir(path, pname=None, enable=None,  disable=None, init=None):
    res = []
    thrs = []
    if pname is None:
        pname = path.split(os.sep)[-1]
    for modname in listmod(path):
        skip = False
        if not modname:
            skip = True
        if disable and include(modname, spl(disable)):
            continue
        if enable and not include(modname, spl(enable)):
            skip = True
        if skip:
            continue
        mname = "%s.%s" % (pname, modname)
        mod = sys.modules.get(mname, None)
        if mod:
            scan(mod)
            if init and "init" in dir(mod):
                thrs.append(launch(mod.init))
            res.append(mod)
    for thr in thrs:
        thr.join()
    return res


def wrap(func):
    fds = sys.stdin.fileno()
    old = termios.tcgetattr(fds)
    try:
        func()
    except (EOFError, KeyboardInterrupt):
        cprint("")
    finally:
        termios.tcsetattr(fds, termios.TCSADRAIN, old)
        for ex in Handler.errors:
            if doskip(str(ex)):
                continue
            traceback.print_exception(type(ex), ex, ex.__traceback__)


def main():
    date = time.ctime(time.time()).replace("  ", " ")
    print(f"TINDER started {date}")
    if os.path.exists(Storage.workdir):
        shutil.rmtree(Storage.workdir)
    e = Event()
    e.parse(" ".join(sys.argv[1:]))
    update(Cfg, e)
    if os.path.exists("mod"):
        from mod import cmd, irc, log, rss
        rss.debug = True
        print("\n".join([str(x) for x in scandir("mod")]))
        print(",".join(Commands.cmds))
    cli = CLI()
    launch(cli.start)
    nrs = Cfg.index or 1
    starttime = time.time()
    waiters = []
    res = 1
    for _nr in range(nrs):
        waiters.append(launch(payload, cli, name=_nr))
    for wtr in waiters:
        res += wtr.join() or 0
    consume(events)
    endtime = time.time()
    print("%s %s %s (%s remaining)" %  (
                                        elapsed(endtime - starttime),
                                        res,
                                        (endtime - starttime)/res, len(events))
                                       )


wrap(main)
